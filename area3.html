<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>AR Gallery â€” three.js WebXR</title>
  <style>
    body{margin:0;overflow:hidden;background:#000}
    #info { position:fixed; left:10px; top:10px; z-index:2; color:#fff; font-family:Arial; }
  </style>
</head>
<body>
  <div id="info">Tap to place. Drag to move.</div>

  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.152.2/build/three.module.js';
    import { ARButton } from 'https://unpkg.com/three@0.152.2/examples/jsm/webxr/ARButton.js';
    import { GLTFLoader } from 'https://unpkg.com/three@0.152.2/examples/jsm/loaders/GLTFLoader.js';

    let camera, scene, renderer;
    let reticle, controller;
    let model = null;
    let hitTestSource = null;
    let localReferenceSpace = null;
    let placed = false;

    init();
    function init() {
      const container = document.createElement('div');
      document.body.appendChild(container);

      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera();

      // Light
      const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
      scene.add(light);

      // Renderer
      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.xr.enabled = true;
      container.appendChild(renderer.domElement);

      document.body.appendChild(ARButton.createButton(renderer, { requiredFeatures: ['hit-test'] }));

      // Reticle (indicator where we will place the model)
      const ringGeometry = new THREE.RingGeometry(0.05, 0.07, 32).rotateX(-Math.PI / 2);
      const ringMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
      reticle = new THREE.Mesh(ringGeometry, ringMaterial);
      reticle.matrixAutoUpdate = false;
      reticle.visible = false;
      scene.add(reticle);

      // Controller (for tapping)
      controller = renderer.xr.getController(0);
      controller.addEventListener('select', onSelect);
      scene.add(controller);

      // Load a GLB model
      const loader = new GLTFLoader();
      loader.load('https://radovansvec.github.io/ARGallery/Area1.glb', (gltf) => {
        model = gltf.scene;
        model.scale.set(0.5,0.5,0.5); // adjust scale as needed
        model.visible = false; // show when placed
        scene.add(model);
      }, undefined, (err)=>console.error(err));

      renderer.setAnimationLoop(render);

      // pointer-based drag support
      let dragging = false;
      let lastHitPosition = new THREE.Vector3();
      renderer.domElement.addEventListener('pointerdown', (e) => {
        // start drag only if model already placed and pointer intersects near it
        if (!placed) return;
        dragging = true;
      });
      renderer.domElement.addEventListener('pointerup', () => dragging = false);

      renderer.domElement.addEventListener('pointermove', (ev) => {
        if (!dragging || !placed) return;
        // perform a new transient hit test and move model to that location
        if (hitTestSource) {
          const session = renderer.xr.getSession();
          const viewerPose = session.getViewerPose(localReferenceSpace);
          // We will do transient hit test using XRFrame in render loop for best accuracy.
        }
      });

      // on session start, request hit test source
      renderer.xr.addEventListener('sessionstart', async () => {
        const session = renderer.xr.getSession();
        localReferenceSpace = await session.requestReferenceSpace('local');
        const viewerSpace = await session.requestReferenceSpace('viewer');

        // request hit test source for persistent hit testing
        const xrHitTestSource = await session.requestHitTestSource({ space: viewerSpace });
        hitTestSource = xrHitTestSource;

        session.addEventListener('end', () => {
          hitTestSource = null;
          placed = false;
          if (model) model.visible = false;
        });
      });
    }

    function onSelect() {
      // Place or re-center the model at the reticle position
      if (reticle.visible && model) {
        model.visible = true;
        model.position.setFromMatrixPosition(reticle.matrix);
        model.quaternion.setFromRotationMatrix(reticle.matrix);
        placed = true;
      }
    }

    function render(timestamp, xrFrame) {
      if (xrFrame) {
        const session = xrFrame.session;
        if (hitTestSource && localReferenceSpace) {
          const hitTestResults = xrFrame.getHitTestResults(hitTestSource);
          if (hitTestResults.length > 0) {
            const hit = hitTestResults[0];
            const pose = hit.getPose(localReferenceSpace);
            reticle.visible = true;
            reticle.matrix.fromArray(pose.transform.matrix);
          } else {
            reticle.visible = false;
          }
        }
      }

      renderer.render(scene, camera);
    }
  </script>
</body>
</html>
